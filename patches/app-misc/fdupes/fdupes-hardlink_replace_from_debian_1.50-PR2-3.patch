diff --git fdupes.1 fdupes.1
index 210234..0344d5 100644
--- fdupes.1
+++ fdupes.1
@@ -52,10 +52,17 @@ prompt user for files to preserve, deleting all others (see
 .B CAVEATS
 below)
 .TP
+.B -L --hardlink
+replace all duplicate files with hardlinks to the
+first file in each set of duplicates
+.TP
 .B -N --noprompt
 when used together with --delete, preserve the first file in each
 set of duplicates and delete the others without prompting the user 
 .TP
+.B -D --debug
+provide debugging information
+.TP
 .B -v --version
 display fdupes version
 .TP
diff --git fdupes.c fdupes.c
index b8abad..573abb 100644
--- fdupes.c
+++ fdupes.c
@@ -51,6 +51,8 @@
 #define F_RECURSEAFTER      0x0200
 #define F_NOPROMPT          0x0400
 #define F_SUMMARIZEMATCHES  0x0800
+#define F_HARDLINKFILES     0x1000
+#define F_DEBUGINFO         0x2000
 
 char *program_name;
 
@@ -866,6 +868,88 @@ void deletefiles(file_t *files, int prompt, FILE *tty)
   free(preservestr);
 }
 
+void hardlinkfiles(file_t *files, int debug)
+{
+  int counter;
+  int groups = 0;
+  int curgroup = 0;
+  file_t *tmpfile;
+  file_t *curfile;
+  file_t **dupelist;
+  int max = 0;
+  int x = 0;
+
+  curfile = files;
+  
+  while (curfile) {
+    if (curfile->hasdupes) {
+      counter = 1;
+      groups++;
+
+      tmpfile = curfile->duplicates;
+      while (tmpfile) {
+	counter++;
+	tmpfile = tmpfile->duplicates;
+      }
+      
+      if (counter > max) max = counter;
+    }
+    
+    curfile = curfile->next;
+  }
+
+  max++;
+
+  dupelist = (file_t**) malloc(sizeof(file_t*) * max);
+
+  if (!dupelist) {
+    errormsg("out of memory\n");
+    exit(1);
+  }
+
+  while (files) {
+    if (files->hasdupes) {
+      curgroup++;
+      counter = 1;
+      dupelist[counter] = files;
+
+      if (debug) printf("[%d] %s\n", counter, files->d_name);
+
+      tmpfile = files->duplicates;
+
+      while (tmpfile) {
+	dupelist[++counter] = tmpfile;
+	if (debug) printf("[%d] %s\n", counter, tmpfile->d_name);
+	tmpfile = tmpfile->duplicates;
+      }
+
+      if (debug) printf("\n");
+
+      /* preserve only the first file */
+
+      printf("   [+] %s\n", dupelist[1]->d_name);
+      for (x = 2; x <= counter; x++) { 
+	  if (unlink(dupelist[x]->d_name) == 0) {
+            if ( link(dupelist[1]->d_name, dupelist[x]->d_name) == 0 ) {
+                printf("   [h] %s\n", dupelist[x]->d_name);
+            } else {
+                printf("-- unable to create a hardlink for the file: %s\n", strerror(errno));
+                printf("   [!] %s ", dupelist[x]->d_name);
+            }
+	  } else {
+	    printf("   [!] %s ", dupelist[x]->d_name);
+	    printf("-- unable to delete the file!\n");
+	  }
+	}
+      printf("\n");
+    }
+    
+    files = files->next;
+  }
+
+  free(dupelist);
+}
+
 int sort_pairs_by_arrival(file_t *f1, file_t *f2)
 {
   if (f2->duplicates != 0)
@@ -954,10 +1038,14 @@ void help_text()
   printf("                  \twith -s or --symlinks, or when specifying a\n");
   printf("                  \tparticular directory more than once; refer to the\n");
   printf("                  \tfdupes documentation for additional information\n");
-  /*printf(" -l --relink      \t(description)\n");*/
+  /* printf(" -r --dlink     \t(description)\n"); */
+  printf(" -L --linkhard    \thardlink duplicate files to the first file in\n");
+  printf("                  \teach set of duplicates without prompting the user\n");
   printf(" -N --noprompt    \ttogether with --delete, preserve the first file in\n");
   printf("                  \teach set of duplicates and delete the rest without\n");
   printf("                  \tprompting the user\n");
+  printf(" -D --debug       \tenable debugging information\n");
+  printf("                  \teach set of duplicates without prompting the user\n");
   printf(" -v --version     \tdisplay fdupes version\n");
   printf(" -h --help        \tdisplay this help message\n\n");
 #ifdef OMIT_GETOPT_LONG
@@ -993,11 +1081,13 @@ int main(int argc, char **argv) {
     { "symlinks", 0, 0, 's' },
     { "hardlinks", 0, 0, 'H' },
     { "relink", 0, 0, 'l' },
+    { "linkhard", 0, 0, 'L' },
     { "noempty", 0, 0, 'n' },
     { "delete", 0, 0, 'd' },
     { "version", 0, 0, 'v' },
     { "help", 0, 0, 'h' },
     { "noprompt", 0, 0, 'N' },
+    { "debug", 0, 0, 'D' },
     { "summarize", 0, 0, 'm'},
     { "summary", 0, 0, 'm' },
     { 0, 0, 0, 0 }
@@ -1011,7 +1101,7 @@ int main(int argc, char **argv) {
 
   oldargv = cloneargs(argc, argv);
 
-  while ((opt = GETOPT(argc, argv, "frRq1Ss::HlndvhNm"
+  while ((opt = GETOPT(argc, argv, "frRq1Ss::HlLndDvhNm"
 #ifndef OMIT_GETOPT_LONG
           , long_options, NULL
 #endif
@@ -1047,6 +1137,12 @@ int main(int argc, char **argv) {
     case 'd':
       SETFLAG(flags, F_DELETEFILES);
       break;
+    case 'L':
+      SETFLAG(flags, F_HARDLINKFILES);
+      break;
+    case 'D':
+      SETFLAG(flags, F_DEBUGINFO);
+      break;
     case 'v':
       printf("fdupes %s\n", VERSION);
       exit(0);
@@ -1081,6 +1177,16 @@ int main(int argc, char **argv) {
     exit(1);
   }
 
+  if (ISFLAG(flags, F_HARDLINKFILES) && ISFLAG(flags, F_DELETEFILES)) {
+    errormsg("options --linkhard and --delete are not compatible\n");
+    exit(1);
+  }
+
+  if (ISFLAG(flags, F_HARDLINKFILES) && ISFLAG(flags, F_CONSIDERHARDLINKS)) {
+    errormsg("options --linkhard and --hardlinks are not compatible\n");
+    exit(1);
+  }
+
   if (ISFLAG(flags, F_RECURSEAFTER)) {
     firstrecurse = nonoptafter("--recurse:", argc, oldargv, argv, optind);
     
@@ -1171,12 +1277,23 @@ int main(int argc, char **argv) {
 
   else 
 
-    if (ISFLAG(flags, F_SUMMARIZEMATCHES))
-      summarizematches(files);
-      
-    else
+    if (ISFLAG(flags, F_HARDLINKFILES))
+
+        if (ISFLAG(flags, F_DEBUGINFO))
+            hardlinkfiles(files, 1);
+        else
+            hardlinkfiles(files, 0);
 
-      printmatches(files);
+    else {
+    
+        if (ISFLAG(flags, F_SUMMARIZEMATCHES))
+            summarizematches(files);
+
+        else
+
+            printmatches(files);
+
+    }
 
   while (files) {
     curfile = files->next;
