From c88c4c468acea43b2b8b4632127ebb6f90abd7ad Mon Sep 17 00:00:00 2001
From: Daniel Mueller <deso@posteo.net>
Date: Sun, 21 Oct 2018 12:58:56 -0700
Subject: [PATCH 2/4] Use visual style for function signature formatting

Most of the time rustfmt's "Block" indentation style does its job pretty
well. However, function signatures look awkward in this formatting. On
the bright side, the "Visual" style produces function signatures that
look just fine. Unfortunately, there is no way to configure rustfmt to
use this style solely for function signatures.
To this end, this change adjusts rustfmt to use the visual style
whenever it formats function signatures. All other artifacts are
formatted just as they were before.
---
 src/items.rs | 21 ++++-----------------
 1 file changed, 4 insertions(+), 17 deletions(-)

diff --git a/src/items.rs b/src/items.rs
index ff6351..6aca83 100644
--- a/src/items.rs
+++ b/src/items.rs
@@ -2024,7 +2024,6 @@ fn rewrite_fn_base(
     )?;
 
     let put_args_in_block = match context.config.indent_style() {
-        IndentStyle::Block => arg_str.contains('\n') || arg_str.len() > one_line_budget,
         _ => false,
     } && !fd.inputs.is_empty();
 
@@ -2059,10 +2058,8 @@ fn rewrite_fn_base(
     // Return type.
     if let ast::FunctionRetTy::Ty(..) = fd.output {
         let ret_should_indent = match context.config.indent_style() {
-            // If our args are block layout then we surely must have space.
-            IndentStyle::Block if put_args_in_block || fd.inputs.is_empty() => false,
             _ if args_last_line_contains_comment => false,
-            _ if result.contains('\n') || multi_line_ret_str => true,
+            _ if result.contains('\n') || multi_line_ret_str => false,
             _ => {
                 // If the return type would push over the max width, then put the return type on
                 // a new line. With the +1 for the signature length an additional space between
@@ -2326,17 +2323,10 @@ fn rewrite_args(
         .map_or(false, |s| s.trim().starts_with("//"));
 
     let (indent, trailing_comma) = match context.config.indent_style() {
-        IndentStyle::Block if fits_in_one_line => {
-            (indent.block_indent(context.config), SeparatorTactic::Never)
-        }
-        IndentStyle::Block => (
-            indent.block_indent(context.config),
-            context.config.trailing_comma(),
-        ),
-        IndentStyle::Visual if last_line_ends_with_comment => {
+        IndentStyle::Visual | IndentStyle::Block if last_line_ends_with_comment => {
             (arg_indent, context.config.trailing_comma())
         }
-        IndentStyle::Visual => (arg_indent, SeparatorTactic::Never),
+        IndentStyle::Visual | IndentStyle::Block => (arg_indent, SeparatorTactic::Never),
     };
 
     let tactic = definitive_tactic(
@@ -2408,10 +2398,7 @@ fn compute_budgets_for_args(
         if one_line_budget > 0 {
             // 4 = "() {".len()
             let (indent, multi_line_budget) = match context.config.indent_style() {
-                IndentStyle::Block => {
-                    let indent = indent.block_indent(context.config);
-                    (indent, context.budget(indent.width() + 1))
-                }
+                IndentStyle::Block |
                 IndentStyle::Visual => {
                     let indent = indent + result.len() + 1;
                     let multi_line_overhead = indent.width() + if newline_brace { 2 } else { 4 };
-- 
2.18.1

