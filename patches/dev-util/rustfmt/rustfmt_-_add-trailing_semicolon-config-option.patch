From e4bbe934c846ee03cb12236d3ea8a35ec5063472 Mon Sep 17 00:00:00 2001
From: topecongiro <seuchida@gmail.com>
Date: Tue, 11 Jul 2017 22:41:38 +0900
Subject: [PATCH] Add trailing_semicolon config option

trailing_semicolon controls whether to add a trailing semicolon after break,
continue and return.
---
 src/config.rs                                    |  1 +
 src/expr.rs                                      |  2 +-
 src/items.rs                                     |  6 +++++-
 src/utils.rs                                     |  9 +++++---
 src/visitor.rs                                   |  2 +-
 tests/target/configs-trailing_semicolon-false.rs | 27 ++++++++++++++++++++++++
 tests/target/configs-trailing_semicolon-true.rs  | 27 ++++++++++++++++++++++++
 7 files changed, 68 insertions(+), 6 deletions(-)
 create mode 100644 tests/target/configs-trailing_semicolon-false.rs
 create mode 100644 tests/target/configs-trailing_semicolon-true.rs

diff --git a/src/config.rs b/src/config.rs
index 931b99..a2d8b5 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -504,6 +504,7 @@ create_config! {
     impl_empty_single_line: bool, true, "Put empty-body implementations on a single line";
     trailing_comma: SeparatorTactic, SeparatorTactic::Vertical,
         "How to handle trailing commas for lists";
+    trailing_semicolon: bool, true, "Add trailing semicolon after break, continue and return";
     fn_empty_single_line: bool, true, "Put empty-body functions on a single line";
     fn_single_line: bool, false, "Put single-expression functions on a single line";
     fn_return_indent: ReturnIndent, ReturnIndent::WithArgs,
diff --git a/src/expr.rs b/src/expr.rs
index d23644..33a94c 100644
--- a/src/expr.rs
+++ b/src/expr.rs
@@ -821,7 +821,7 @@ impl Rewrite for ast::Stmt {
             ast::StmtKind::Local(ref local) => local.rewrite(context, shape),
             ast::StmtKind::Expr(ref ex) |
             ast::StmtKind::Semi(ref ex) => {
-                let suffix = if semicolon_for_stmt(self) { ";" } else { "" };
+                let suffix = if semicolon_for_stmt(context, self) { ";" } else { "" };
 
                 format_expr(
                     ex,
diff --git a/src/items.rs b/src/items.rs
index a660f2..3d27e9 100644
--- a/src/items.rs
+++ b/src/items.rs
@@ -351,7 +351,11 @@ impl<'a> FmtVisitor<'a> {
                 if let Some(ref stmt) = block.stmts.first() {
                     match stmt_expr(stmt) {
                         Some(e) => {
-                            let suffix = if semicolon_for_expr(e) { ";" } else { "" };
+                            let suffix = if semicolon_for_expr(&self.get_context(), e) {
+                                ";"
+                            } else {
+                                ""
+                            };
 
                             e.rewrite(
                                 &self.get_context(),
diff --git a/src/utils.rs b/src/utils.rs
index 0d1b32..e6456c 100644
--- a/src/utils.rs
+++ b/src/utils.rs
@@ -147,17 +147,17 @@ pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {
 }
 
 #[inline]
-pub fn semicolon_for_expr(expr: &ast::Expr) -> bool {
+pub fn semicolon_for_expr(context: &RewriteContext, expr: &ast::Expr) -> bool {
     match expr.node {
         ast::ExprKind::Ret(..) |
         ast::ExprKind::Continue(..) |
-        ast::ExprKind::Break(..) => true,
+        ast::ExprKind::Break(..) => context.config.trailing_semicolon(),
         _ => false,
     }
 }
 
 #[inline]
-pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {
+pub fn semicolon_for_stmt(context: &RewriteContext, stmt: &ast::Stmt) -> bool {
     match stmt.node {
         ast::StmtKind::Semi(ref expr) => {
             match expr.node {
@@ -165,6 +165,9 @@ pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {
                 ast::ExprKind::WhileLet(..) |
                 ast::ExprKind::Loop(..) |
                 ast::ExprKind::ForLoop(..) => false,
+                ast::ExprKind::Break(..) |
+                ast::ExprKind::Continue(..) |
+                ast::ExprKind::Ret(..) => context.config.trailing_semicolon(),
                 _ => true,
             }
         }
diff --git a/src/visitor.rs b/src/visitor.rs
index 9ed40c..44c33a 100644
--- a/src/visitor.rs
+++ b/src/visitor.rs
@@ -132,7 +132,7 @@ impl<'a> FmtVisitor<'a> {
 
         if !b.stmts.is_empty() {
             if let Some(expr) = utils::stmt_expr(&b.stmts[b.stmts.len() - 1]) {
-                if utils::semicolon_for_expr(expr) {
+                if utils::semicolon_for_expr(&self.get_context(), expr) {
                     self.buffer.push_str(";");
                 }
             }
diff --git a/tests/target/configs-trailing_semicolon-false.rs b/tests/target/configs-trailing_semicolon-false.rs
new file mode 100644
index 000000..9fa746
--- /dev/null
+++ b/tests/target/configs-trailing_semicolon-false.rs
@@ -0,0 +1,27 @@
+// rustfmt-trailing_semicolon: false
+
+#![feature(loop_break_value)]
+
+fn main() {
+    'a: loop {
+        break 'a
+    }
+
+    let mut done = false;
+    'b: while !done {
+        done = true;
+        continue 'b
+    }
+
+    let x = loop {
+        break 5
+    };
+
+    let x = 'c: loop {
+        break 'c 5
+    };
+}
+
+fn foo() -> usize {
+    return 0
+}
diff --git a/tests/target/configs-trailing_semicolon-true.rs b/tests/target/configs-trailing_semicolon-true.rs
new file mode 100644
index 000000..61b684
--- /dev/null
+++ b/tests/target/configs-trailing_semicolon-true.rs
@@ -0,0 +1,27 @@
+// rustfmt-trailing_semicolon: true
+
+#![feature(loop_break_value)]
+
+fn main() {
+    'a: loop {
+        break 'a;
+    }
+
+    let mut done = false;
+    'b: while !done {
+        done = true;
+        continue 'b;
+    }
+
+    let x = loop {
+        break 5;
+    };
+
+    let x = 'c: loop {
+        break 'c 5;
+    };
+}
+
+fn foo() -> usize {
+    return 0;
+}
-- 
2.16.4

